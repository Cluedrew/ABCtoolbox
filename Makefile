# Make file for the ABC Tool Box:
# See DevManual.txt for details.

###
#
# Currantly there is an issue with this set up, I have realized that I am not
# nessasily going to provide a header and an exicutable for every tool, plus
# I may include other files, such as tpp files, or do a number of other things
# to create my output files. Not only does the Makefile not support these
# options but there is no easy way to add them in its currant form. So I need
# to fix it. In addition to what I have currantly:
# * An easy way to check if certain files (the public header, the origin cpp)
#   exist for a particular tool.
# * Conditional dependances, for instance files with no origin cpp will not
#   have a lib*.a file made for them.
# * Possibly something for stitching files together for 'single header'
#   exports. (Or header and header extention, I like clean headers.)
#
###

# The names of all of the tools.
TOOLLIST= hello-world filter-it



### Main Variable Declaration:
# Access Link Varibles:
LINKDIR=/usr/local/include
LINKNAME=$(LINKDIR)/ABC
LINKDEST=/home/cluedrew/ABCtoolbox/include # *
# The system is likely to be replaced eventually with a proper install.
# * This should be replaced that finds the location of this file, so it always
#   gets the correct location of /include.

# Compiler Varaibles:
CXX=gcc
CXXFLAGS=-Wall -MMD -std=c++11

# Link Varibles:
LINK=ld
LINKFLAGS=-Ur

# Directory names:
# Code/Source Directory, holds raw files not created by make.
SORDIR=code
# Object/Intermediate Directory, files both generated and used by make
#   which are mostly objects. Also a temperary file.
OBJDIR=.obj
# Library/Target Directory, holds the end results of make.
LIBDIR=include
# Testing Directory, not part of main process, has the tests and the test
#   programs which are used to test the compliled tools.
TSTDIR=test



### Special Rules:
.PHONY : all clean deepclean $(TOOLLIST) link delink
.SECONDEXPANSION :

### Misc Varibles:
# All .cpp Files
ALLCPP= $(wildcard $(SORDIR)/*/*.cpp)
# Intermediate Objects
INTOBJ= $(patsubst $(SORDIR)%.cpp,$(OBJDIR)%.o,$(ALLCPP))
# Finished or Linked Objects
FINOBJ= $(patsubst %,$(OBJDIR)/%.o,$(TOOLLIST))
# Dependancy Files
DEPEND= $(INTOBJ:.o=.d)

# Creates a *_OBJ varible for each tool. Each varible holds the intermediate
#   object files for that tool.
$(foreach tool,$(TOOLLIST), \
	$(eval $(tool)_OBJ= $(filter $(OBJDIR)/$(tool)/%.o,$(INTOBJ))))

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Creates a *_TARGET variable for each tool. Each variable holds the final
#   targets assosated with each tool.
$(foreach tool,$(TOOLLIST), \
	$(eval $(tool)_TARGET= \
# A public header will always be used. (hpp => hpp)
	$(LIBDIR)/$(tool).hpp \
# A compiled binary might be used. (cpp => lib_.a)
	$(if ?,$(LIBDIR)/lib$(tool).a) \
# A template/header extentention file might be used. (tpp => tpp)
# Can I stich together multiple files here?
	$(if ?,$(LIBDIR)/$(tool).tpp) )



### Functions:
# Expands to the contents of the file $(1) if file exists.
#   If the file does not exist expands to the empty string.
safecat= $(shell [ -e $(1) ] && cat $(1))

# Turns the names of tools it is given to the names of the tool's final
#   files, toollib is the library file, toolhead is the public header and
#   end files produces both.
endfiles= $(foreach tool,$(1),$(LIBDIR)/$(tool).hpp $(LIBDIR)/lib$(tool).a)
toollib = $(foreach tool,$(1),$(LIBDIR)/lib$(tool).a)
toolhead= $(foreach tool,$(1),$(LIBDIR)/$(tool).hpp)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Get the contents of every #include "%" statement in the file $(1).
get_local_include=$(patsubst include "%",%, \
	$(shell egrep "include \".*\" " $(1)))
# If I can get this, and then call it recursively, than I could make that
# sticking program I wanted.


### Rules:

# Default rule, updates all tools.
all : $(TOOLLIST)

# Tool level rule, create all final files for a tool.
$(TOOLLIST) : $(LIBDIR)/lib%.a $(LIBDIR)/%.hpp

# Create the static library in the include directory.
$(LIBDIR)/lib%.a : $(OBJDIR)/%.o | $(LIBDIR)
	ar rcs $@ $<

# Copy the public header over to the include directory.
$(LIBDIR)/%.hpp : $(SORDIR)/%/$$*.hpp | $(LIBDIR)
	cp $< $@
# Check for a matching tpp: remove old and create new. (...it works)
	[ -e $(@:hpp=tpp) ] && rm $(@:hpp=tpp) || true
	[ -e $(<:hpp=tpp) ] && cp $(<:hpp=tpp) $(@:hpp=tpp) || true

# Rule for final objects (objects generated by linking)
$(FINOBJ) : $(OBJDIR)/%.o : $$($$*_OBJ) | $(OBJDIR)
	$(LINK) $(LINKFLAGS) $^ $(call safecat, $(SORDIR)/$*/libs) -o $@

# Rule for intermediate objects (objects created from code)
$(INTOBJ) : $(OBJDIR)/%.o : $(SORDIR)/%.cpp | $(OBJDIR)/$$(dir $$*)
	$(CXX) $(CXXFLAGS) -c $< -o $@



# Rules for link creation and destruction.
# Might require special permitions.
link : $(LINKNAME)

delink :
	rm $(LINKNAME)

$(LINKNAME) :
	ln --symbolic -T $(LINKDEST) $@



# Directory creation.
$(OBJDIR) $(LIBDIR) : ; mkdir $@
$(patsubst %,$(OBJDIR)/%/,$(TOOLLIST)) : | $(OBJDIR) ; mkdir $@



# Add dependancy files.
-include $(DEPEND)

# clean phony rule. Removes all intermetiate files.
clean :
	-rm $(OBJDIR)/*/*.o
	-rm $(OBJDIR)/*/*.d
	-rm $(OBJDIR)/*.o
	-rmdir $(OBJDIR)/*
	-rmdir $(OBJDIR)

# deepclean phony rule. Removes all generated files.
deepclean : clean
	-rm $(LIBDIR)/*.{hpp,a,tpp}
	-rmdir $(LIBDIR)
